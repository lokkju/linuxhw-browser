--- a/edid-decode.cpp
+++ b/edid-decode.cpp
@@ -2643,4 +2643,36 @@ extern "C" int parse_edid(const char *input)
 	return ret ? ret : state.parse_edid();
 }

+/*
+ * Buffer-based entry point for WASM - skips filesystem entirely.
+ * Takes raw EDID bytes directly instead of reading from a file.
+ */
+extern "C" int parse_edid_buffer(const unsigned char *data, unsigned int len)
+{
+	for (unsigned i = 0; i < EDID_MAX_BLOCKS + 1; i++) {
+		s_msgs[i][0].clear();
+		s_msgs[i][1].clear();
+	}
+	options[OptCheck] = 1;
+	options[OptPreferredTimings] = 1;
+	options[OptNativeResolution] = 1;
+	options[OptSkipSHA] = 0;
+	options[OptUTF8] = 1;
+	state = edid_state();
+
+	// Validate and copy buffer directly
+	if (len < EDID_PAGE_SIZE || len > sizeof(edid)) {
+		fprintf(stderr, "Invalid EDID size: %u bytes\n", len);
+		return -1;
+	}
+	if (memcmp(data, "\x00\xFF\xFF\xFF\xFF\xFF\xFF\x00", 8)) {
+		fprintf(stderr, "No EDID header found.\n");
+		return -1;
+	}
+	memcpy(edid, data, len);
+	state.edid_size = len;
+	state.num_blocks = len / EDID_PAGE_SIZE;
+
+	return state.parse_edid();
+}
+
 #endif
